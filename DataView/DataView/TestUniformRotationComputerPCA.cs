using System;
using System.Collections.Generic;
using MathNet.Numerics.LinearAlgebra;

namespace DataView
{
    /// <summary>
    /// This class works the same as TestRotationComputerPCA,
    /// but the basis of micro and macro data is generated by getting uniformly distributed values
    /// </summary>
    class TestUniformRotationComputerPCA
    {

        public static double radius = 1;

        /// <summary>
        /// Calculates the rotation matrix from dMicro to dMacro
        /// </summary>
        /// <param name="dMicro">Data1</param>
        /// <param name="dMacro">Data2</param>
        /// <param name="pointMicro">Point in data1 to take samples around</param>
        /// <param name="pointMacro">Point in data2 to take samples around</param>
        /// <param name="count">Number of samples taken</param>
        /// <returns></returns>
        public static Matrix<double> CalculateRotation(IData dMicro, IData dMacro, Point3D pointMicro, Point3D pointMacro, double spacing)
        {
            Matrix<double> basisMicro;
            Matrix<double> basisMacro;

            spacing = 0.3;

            try
            {
                basisMicro = GetPointBasis(dMicro, pointMicro, spacing, radius);
                basisMacro = GetPointBasis(dMacro, pointMacro, spacing, radius);
            }
            catch (Exception e) { throw e; }

            Matrix<double> transitionMatrix = Matrix<double>.Build.Dense(3, 3);

            Matrix<double> equationMatrix = Matrix<double>.Build.Dense(3, 4);


            //Calculation of the transition matrix
            for (int basisNumber = 0; basisNumber<3; basisNumber++)
            {
                for (int i = 0; i < 3; i++)
                    equationMatrix.SetColumn(i, basisMicro.Column(i));

                equationMatrix.SetColumn(3, basisMacro.Column(basisNumber));

                Vector<double> result;

                try { result = EquationComputer.CalculateSolution(equationMatrix); }
                catch (Exception e) { throw e; }

                transitionMatrix.SetColumn(basisNumber, result);
            }

            //Replace 0 values
            for(int i = 0; i<transitionMatrix.RowCount; i++)
            {
                for(int j = 0; j<transitionMatrix.ColumnCount; j++)
                {
                    if (Math.Abs(transitionMatrix[i, j]) <= Double.Epsilon)
                        transitionMatrix[i, j] = 0;
                }
            }


            if (pointMacro.Distance(pointMicro) <= 1)
            {
                Console.WriteLine("These points are relatively close: ");
                Console.WriteLine(pointMicro);
                Console.WriteLine(pointMacro);

                Console.WriteLine("This is the basis for pointMicro: " + basisMicro);
                Console.WriteLine("This is the basis for pointMacro: " + basisMacro);
                Console.WriteLine("This is their transition matrix: " + transitionMatrix);
            }

            return transitionMatrix;
        }

        /// <summary>
        /// This method tests whether the given vectors are parallel or antiparallel.
        /// Both of the passed vectors are expected to have dimension 3
        /// </summary>
        /// <param name="vectorA">First vector</param>
        /// <param name="vectorB">Second vector</param>
        /// <returns>Returns true if vectors are parallel or antiparallel, otherwise false.</returns>
        /// <exception cref="ArgumentException">Exception when the given arguments</exception>
        /// 
        private static bool ParallelVectors(Vector<double> vectorA, Vector<double> vectorB)
        {
            if (vectorA.Count != 3)
                throw new ArgumentException("VectorA is expected to have dimension 3");
            if (vectorB.Count != 3)
                throw new ArgumentException("VectorB is expected to have dimension 3");
            if (vectorA.Equals(Vector<double>.Build.Dense(3)))
                throw new ArgumentException("VectorA has only zeros.");
            if(vectorB.Equals(Vector<double>.Build.Dense(3)))
                throw new ArgumentException("VectorB has only zeros.");

            double scalingFactor = vectorA[0] / vectorB[0];
            for(int i = 1; i<vectorA.Count; i++)
            {
                double scaledVector = vectorB[i] * scalingFactor;
                if (compareWithTolerance(scaledVector, vectorA[i]) || compareWithTolerance(scaledVector, -vectorA[i]))
                    return true;
            }
            return false;
        }

        /// <summary>
        /// Compares numberA to numberB and returns true if the numbers are ~ the same
        /// </summary>
        /// <param name="numberA">First number</param>
        /// <param name="numberB">Second number</param>
        /// <returns>Returns true if the numbers are ~ the same, otherwise returns false</returns>
        private static bool compareWithTolerance(double numberA, double numberB)
        {
            double epsilon = 0.00000001;
            if ((numberA + epsilon > numberB) && (numberA - epsilon < numberB))
                return true;
            
            return false;
        }

        /// <summary>
        /// Finds orthogonal vector to the one passed as a parameter
        /// </summary>
        /// <param name="inputVector"></param>
        /// <returns></returns>
        /// <exception cref="ArgumentException"></exception>
        private static Vector<double> findOrthogonalVector(Vector<double> inputVector)
        {
            if (inputVector.Count != 3)
                throw new ArgumentException("Vector needs to have dimension 3");

            Vector<double> orthogonalVector = Vector<double>.Build.Dense(3);
            double a1 = 1;
            double b1 = 1;

            orthogonalVector[0] = a1;
            orthogonalVector[1] = b1;
            orthogonalVector[2] = (inputVector[0] * a1 + inputVector[1] * b1) / (-inputVector[2]);

            return orthogonalVector;
        }

        /// <summary>
        /// Normalizes vector passsed as a parameter
        /// </summary>
        /// <param name="vector">Vector to normalize</param>
        /// <returns>
        /// Returns normalized vector if its magnitude is not equal to 0.
        /// Otherwise it returns Vector with 3 rows and 0 columns.
        /// </returns>
        private static Vector<double> NormalizeVector(Vector<double> vector) {

            double magnitude = vector.L2Norm();

            //Prevents from crashing when denominator(magnitude) is equal to 0
            if (magnitude == 0)
                return Vector<double>.Build.Dense(3, 0);

            return vector / magnitude;
        }

        /// <summary>
        /// Computes the crossProduct of vectors size 3
        /// </summary>
        /// <param name="u"></param>
        /// <param name="v"></param>
        /// <returns></returns>
        private static Matrix<double> CrossProduct(Vector<double> u, Vector<double> v)
        {
            Matrix<double> w = Matrix<double>.Build.Dense(1,3);
            w[0, 0] = u[1] * v[2] - v[1] * u[2];
            w[0, 1] = v[0] * u[2] - u[0] * v[2];
            w[0, 2] = u[0] * v[1] - v[0] * u[1];
            return w;
        }

        // od pana Váši
        private static Matrix<double> GetPointBasis(IData d, Point3D point, double spacing, double radius)
        {
            List<Point3D> pointsInSphere = GetSphere(point, radius, spacing);

            List<double> values = new List<double>();
            double min = double.MaxValue;
            double max = double.MinValue;

            Point3D wAvgHigh = new Point3D(0, 0, 0);
            Point3D wAvgLow = new Point3D(0, 0, 0);

            double wsHigh = 0;
            double wsLow = 0;


            for (int i = 0; i < pointsInSphere.Count; i++)
            {
                try { values.Add(d.GetValue(pointsInSphere[i])); }
                catch { continue; } //The value is not within the bounds of the image
                min = Math.Min(min, values[values.Count - 1]);
                max = Math.Max(max, values[values.Count - 1]);
            }

            //Values min and max are the same
            if (Math.Abs(min - max) < Double.Epsilon)
                throw new ArgumentException("Basis cannot be calculated because all sampled values in the point surrounding are the same.");

            for (int i = 0; i < values.Count; i++)
            {
                double wHigh = (values[i] - min) / (max - min); //percentage from the overall range
                double wLow = 1 - wHigh;

                wsLow += wLow;
                wsHigh += wHigh;

                wAvgHigh.X += pointsInSphere[i].X * wHigh;
                wAvgHigh.Y += pointsInSphere[i].Y * wHigh;
                wAvgHigh.Z += pointsInSphere[i].Z * wHigh;

                wAvgLow.X += pointsInSphere[i].X * wLow;
                wAvgLow.Y += pointsInSphere[i].Y * wLow;
                wAvgLow.Z += pointsInSphere[i].Z * wLow;
            }


            wAvgHigh.X /= wsHigh;
            wAvgHigh.Y /= wsHigh;
            wAvgHigh.Z /= wsHigh;

            wAvgLow.X /= wsLow;
            wAvgLow.Y /= wsLow;
            wAvgLow.Z /= wsLow;

            double diffXHigh = wAvgHigh.X - point.X;
            double diffYHigh = wAvgHigh.Y - point.Y;
            double diffZHigh = wAvgHigh.Z - point.Z;

            double diffXLow = wAvgLow.X - point.X;
            double diffYLow = wAvgLow.Y - point.Y;
            double diffZLow = wAvgLow.Z - point.Z;


            Vector<double> highConcentrationVector = Vector<double>.Build.Dense(3);
            highConcentrationVector[0] = diffXHigh;
            highConcentrationVector[1] = diffYHigh;
            highConcentrationVector[2] = diffZHigh;

            Vector<double> lowConcentrationVector = Vector<double>.Build.Dense(3);
            lowConcentrationVector[0] = diffXLow;
            lowConcentrationVector[1] = diffYLow;
            lowConcentrationVector[2] = diffZLow;

            highConcentrationVector = NormalizeVector(highConcentrationVector);
            lowConcentrationVector = NormalizeVector(lowConcentrationVector);

            Vector<double> crossProductVector = Vector<double>.Build.Dense(3);

            if (ParallelVectors(highConcentrationVector, lowConcentrationVector))
                crossProductVector = findOrthogonalVector(highConcentrationVector);
            else
                crossProductVector = CrossProduct(highConcentrationVector, lowConcentrationVector).Row(0);

            crossProductVector = NormalizeVector(crossProductVector);


            Matrix<double> resultMatrix = Matrix<double>.Build.Dense(3, 3);

            //The matrix is composed out of unit vectors

            resultMatrix[0, 0] = highConcentrationVector[0];
            resultMatrix[1, 0] = highConcentrationVector[1];
            resultMatrix[2, 0] = highConcentrationVector[2];

            resultMatrix[0, 1] = lowConcentrationVector[0];
            resultMatrix[1, 1] = lowConcentrationVector[1];
            resultMatrix[2, 1] = lowConcentrationVector[2];

            resultMatrix[0, 2] = crossProductVector[0];
            resultMatrix[1, 2] = crossProductVector[1];
            resultMatrix[2, 2] = crossProductVector[2];

            return resultMatrix;
        }

        /// <summary>
        /// This method prints generated points in a sphere that are 
        /// </summary>
        /// <param name="pointsInSphere"></param>
        private static void PrintGeneratedPoints(List<Point3D> pointsInSphere)
        {
            string pointsX = "[";
            for (int i = 0; i < pointsInSphere.Count; i++)
            {
                pointsX = pointsX + (pointsInSphere[i].X.ToString().Replace(",", ".")) + ", ";
            }
            pointsX = pointsX + "]";
            Console.WriteLine(pointsX);

            string pointsY = "[";
            for (int i = 0; i < pointsInSphere.Count; i++)
            {
                pointsY = pointsY + (pointsInSphere[i].Y.ToString().Replace(",", ".")) + ", ";
            }
            pointsY = pointsY + "]";
            Console.WriteLine(pointsY);

            string pointsZ = "[";
            for (int i = 0; i < pointsInSphere.Count; i++)
            {
                pointsZ = pointsZ + (pointsInSphere[i].Z.ToString().Replace(",", ".")) + ", ";
            }
            pointsZ = pointsZ + "]";
            Console.WriteLine(pointsZ);
        }

        /// <summary>
        /// Gets points uniformly distributed from the center point
        /// </summary>
        /// <param name="p">Center around which the points are generated</param>
        /// <param name="r">Generated point's distance from the center</param>
        /// <param name="spacing">Spacing between the points</param>
        /// <returns>A grid of points uniformly distributed in the sphere radius from a given point.</returns>
        private static List<Point3D> GetSphere(Point3D p, double r, double spacing)
        {
            List<Point3D> points = new List<Point3D>();

            for(double x = -r; x<=r; x+=spacing)
            {
                for(double y = -r; y<=r; y+=spacing)
                {
                    SphereBounds zBounds;

                    try { zBounds = GetSphereBounds(x, y, r); }
                    catch { continue; } //No point in z is in the bounds

                    for (double z = zBounds.MinCoordinate; z <= zBounds.MaxCoordinate; z += spacing)
                        points.Add(new Point3D(x, y, z));
                }
            }

            return points;
        }


        /// <summary>
        /// Given an x and y coordinates, this method will generate a min and max z coordinate
        /// so that [x, y, z] are inside a sphere specified by given radius
        /// </summary>
        /// <param name="x">Coordinate X</param>
        /// <param name="y">Coordinate Y</param>
        /// <param name="radius">Radius of a sphere</param>
        /// <returns>Returns instance of SphereBounds where are the min and max Z values.</returns>
        /// <exception cref="ArgumentException">Throws an exception if the bounds for Z don't exist.</exception>
        private static SphereBounds GetSphereBounds(double x, double y, double radius)
        {
            double rSquared = Math.Pow(radius, 2);
            double zSquared = rSquared - Math.Pow(x, 2) - Math.Pow(y, 2);

            if (zSquared < 0)
                throw new ArgumentException("No values are within bounds for the given X, Y coordinates and given radius");

            double minZ = -Math.Sqrt(zSquared);
            double maxZ = -minZ;

            return new SphereBounds(minZ, maxZ);
        }

        /// <summary>
        /// Returns random number within the specified bounds
        /// </summary>
        /// <param name="minimum">Minimum number to be generated</param>
        /// <param name="maximum">Maximum number to be generated</param>
        /// <param name="r">Instance of Random class</param>
        /// <returns></returns>
        private static double GetRandomDouble(double minimum, double maximum, Random r)
        {
            return r.NextDouble() * (maximum - minimum) + minimum;
        }

        /// <summary>
        /// This is a messenger class for passing min and max bounds
        /// </summary>
        private class SphereBounds
        {
            private double minCoordinate;
            private double maxCoordinate;

            public SphereBounds(double minCoordinate, double maxCoordinate)
            {
                this.minCoordinate = minCoordinate;
                this.maxCoordinate = maxCoordinate;
            }

            //GETTERS
            public double MinCoordinate
            {
                get { return minCoordinate; }
            }

            public double MaxCoordinate
            {
                get { return maxCoordinate; }
            }
        }
    }
}